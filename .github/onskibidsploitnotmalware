
while not game:IsLoaded() do
    task.wait(0.1)
end


RetryDelay = 300 -- in seconds right now 10
speed = 10 -- choose speed
Webhook = "https://discord.com/api/webhooks/1327225260818432052/d7heTdHqlfG40rzDfe7Ciz8YyuyfWHyeF1NM3TlzQvOoFAxolQw-ZlBJ8s529dvWiEE_" -- obvious
discordID = "1058505738667958393" -- very obvious

while not game:IsLoaded() do
    task.wait(1)
end


getgenv().print = function() end
getgenv().warn = function() end
local replicatedStorage = game:GetService("ReplicatedStorage")
local workspaceService = game:GetService("Workspace")
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local TeleportService = game:GetService("TeleportService")
local http = game:GetService("HttpService");
local VIM = game:GetService("VirtualInputManager");
local Players = game:GetService("Players");
local ReplicatedStorage = game:GetService("ReplicatedStorage");
local LocalPlayer = Players.LocalPlayer;
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

if game.PlaceId == 14916516914 then
Fluent:Notify({
        Title = "Not Supported In Lobby for now",
        Content = "Please execute in a mission or raid",
        SubContent = "Thank you", 
        Duration = 5 
})
elseif game.PlaceId == 13379208636 then

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local player = game:GetService("Players").LocalPlayer
local familyTitle = player.PlayerGui.Interface.Customisation.Family.Family.Title
local virtualInputManager = game:GetService("VirtualInputManager")
local VIP = game:GetService("VirtualInputManager")
local http = game:GetService("HttpService") 

local lastFamily = ""
local foundRare = false
local maxSameFamilyTime = 10
local lastChangeTime = os.clock()

function SpecialSpin()
    VIP:SendKeyEvent(true, Enum.KeyCode.Left, false, game)
    task.wait(0.1)
    VIP:SendKeyEvent(false, Enum.KeyCode.Left, false, game)
    task.wait(0.1)
    VIP:SendKeyEvent(true, Enum.KeyCode.Left, false, game)
    task.wait(0.1)
    VIP:SendKeyEvent(false, Enum.KeyCode.Left, false, game)
    task.wait(0.1)
    VIP:SendKeyEvent(true, Enum.KeyCode.Left, false, game)
    task.wait(0.1)
    VIP:SendKeyEvent(false, Enum.KeyCode.Left, false, game)
    task.wait(0.1)
    VIP:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
    task.wait(0.1)
    VIP:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
    task.wait(1)
    VIP:SendKeyEvent(true, Enum.KeyCode.Right, false, game)
    task.wait(0.1)
    VIP:SendKeyEvent(false, Enum.KeyCode.Right, false, game)
    task.wait(0.1)
    VIP:SendKeyEvent(true, Enum.KeyCode.Right, false, game)
    task.wait(0.1)
    VIP:SendKeyEvent(false, Enum.KeyCode.Right, false, game)
    task.wait(0.1)
    VIP:SendKeyEvent(true, Enum.KeyCode.Right, false, game)
    task.wait(0.1)
    VIP:SendKeyEvent(false, Enum.KeyCode.Right, false, game)
end

local function spin()
    VIP:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
    task.wait(0.1)
    VIP:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
end

local function checkRarity(targetRarities)
    local family = familyTitle.Text
    for _, rarity in pairs(targetRarities) do
        if string.find(family, rarity) then
            return true
        end
    end
    return false
end

local function sendMessage(title, family)
    local data = {
        content = "<@" .. discordID .. ">",
        embeds = {{
            title = title,
            description = "You have received the family: " .. family,
            color = 4286945 
        }}
    }
    local actual = http:JSONEncode(data)

    local success, response = pcall(function()
        request({
            Url = Webhook,
            Method = "POST",
            Body = actual,
            Headers = {
                ["content-Type"] = "application/json"
            }
        })
    end)
end

local function startSpinning(targetRarities)
    foundRare = false
    while not foundRare do
        local family = familyTitle.Text
        local currentTime = os.clock()
        local rollsText = player.PlayerGui.Interface.Customisation.Family.Buttons_2.Roll.Title.Text

        if family ~= lastFamily then
            lastFamily = family
            lastChangeTime = currentTime

            if checkRarity(targetRarities) then
                foundRare = true
                sendMessage("Target Family Found", family)
            else
                spin()
                task.wait(0.3)
                local Frame = player.PlayerGui.Interface:FindFirstChild("Frame")
                if Frame then
                    SpecialSpin()
                end
            end
        else
            if (currentTime - lastChangeTime) >= maxSameFamilyTime then
                spin()
                lastChangeTime = currentTime
            end
        end

        if rollsText == "ROLL (0)" then
            break
        end

        task.wait(0.1)
    end
end

local Window = Fluent:CreateWindow({
    Title = "Nexus Hub AoT:R",
    SubTitle = "by Ash",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = "Darker",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Family = Window:AddTab({ Title = "Family", Icon = "" }),
}
Window:SelectTab(1)
Tabs.Family:AddButton({
    Title = "AutoSpin",
    Description = "Press to Initialize Auto Spin",
    Callback = function()
        VIP:SendKeyEvent(true, Enum.KeyCode.BackSlash, false, game)
        task.wait(0.1)
        VIP:SendKeyEvent(true, Enum.KeyCode.Right, false, game)
        task.wait(0.1)
        VIP:SendKeyEvent(true, Enum.KeyCode.Right, false, game)
        task.wait(0.1)
        VIP:SendKeyEvent(true, Enum.KeyCode.Right, false, game)
    end
})

Tabs.Family:AddButton({
    Title = "Stop on Epic",
    Description = "Spin until you get an Epic family (PRESS AUTOSPIN FIRST)",
    Callback = function()
        startSpinning({"%(Epic%)"})
    end
})

Tabs.Family:AddButton({
    Title = "Stop on Legendary",
    Description = "Spin until you get a Legendary family (PRESS AUTOSPIN FIRST)",
    Callback = function()
        startSpinning({"%(Legendary%)"})
    end
})

Tabs.Family:AddButton({
    Title = "Stop on Secret",
    Description = "Spin until you get a Secret family (PRESS AUTOSPIN FIRST)",
    Callback = function()
        startSpinning({"%(Secret%)"})
    end
})

Tabs.Family:AddButton({
    Title = "Stop on Secret and Legendary",
    Description = "Spin until you get a Secret or Legendary family (PRESS AUTOSPIN FIRST)",
    Callback = function()
        startSpinning({"%(Secret%)", "%(Legendary%)"})
    end
})

Tabs.Family:AddButton({
    Title = "Stop on Legendary and Epic",
    Description = "Spin until you get a Legendary or Epic family (PRESS AUTOSPIN FIRST)",
    Callback = function()
        startSpinning({"%(Legendary%)", "%(Epic%)"})
    end
})

Tabs.Family:AddButton({
    Title = "Stop on All 3",
    Description = "Spin until you get a Secret, Legendary, or Epic family (PRESS AUTOSPIN FIRST)",
    Callback = function()
        startSpinning({"%(Secret%)", "%(Legendary%)", "%(Epic%)"})
    end
})


else 

local replicatedStorage = game:GetService("ReplicatedStorage")
local objectives = replicatedStorage:WaitForChild("Objectives")

local slay = objectives:FindFirstChild("Slay")
if slay then
    
    while not slay:GetAttribute("Requirement") do
        task.wait(0.1)
    end

  
    local waitForTitansNumber = slay:GetAttribute("Requirement")
    local workspaceService = game:GetService("Workspace")
    local titansFolder = workspaceService:WaitForChild("Titans")

 
    if slay.Value == 0 then
        while #titansFolder:GetChildren() < waitForTitansNumber do
            task.wait(0.1)
        end
    end

    print("Slay objective condition met!")

else

    local defendEren = objectives:FindFirstChild("Defend_Eren")
    if defendEren then
        print("Slay isn't present, but Defend_Eren exists.")
    else
        warn("Neither Slay nor Defend_Eren exist.")
    end
end

print("Objective requirement detected!")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local workspace = game:GetService("Workspace")
local cf = workspace:WaitForChild("Characters")
local cfc = cf:WaitForChild(player.Name)
local rigChildName = "Rig_" .. player.Name
local rigChild = cfc:WaitForChild(rigChildName)
	local Window = Fluent:CreateWindow({
    Title = "Nexus Hub AoT:R",
    SubTitle = "by Ash",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true, 
    Theme = "Darker",
    MinimizeKey = Enum.KeyCode.LeftControl 
})
local Tabs = {
    Main = Window:AddTab({ Title = "Main", Icon = "" }),
    Extras = Window:AddTab({ Title = "Extras", Icon = "" }),
    Misc = Window:AddTab({ Title = "Misc", Icon = "" }),
    Discord = Window:AddTab({ Title = "Discord", Icon = "" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "" }),
}

Tabs.Discord:AddParagraph({
    Title = "Discord Invite",
    Content = "https://discord.gg/3GaHgcGGhv"
})
Tabs.Discord:AddButton({
    Title = "Copy Discord Invite",
    Description = "Copy Discord Invite",
    Callback = function()
   setclipboard("https://discord.gg/3GaHgcGGhv")
    end
})


InterfaceManager:SetFolder("NexusHub")
SaveManager:SetFolder("NexusHub/settings")

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab(1)


-- Services
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local placeId = 14916516914 -- Replace with the actual lobby PlaceId
local missionFile = "mission_count.txt"

-- Get saved mission count (or 0 if the file doesn't exist)
local function getMissionCount()
    local count = 0
    if isfile(missionFile) then
        local content = readfile(missionFile)
        count = tonumber(content) or 0
    end
    return count
end

-- Save mission count to file
local function setMissionCount(count)
    writefile(missionFile, tostring(count))
end

-- Teleport to lobby and reset mission count
local function teleportToLobby()
    print("[Teleport] 10 missions done! Going to lobby.")
    setMissionCount(0) -- Reset BEFORE teleport
    TeleportService:Teleport(placeId, player)
end

-- Flag to control whether auto-tracking is on
local autoTrackEnabled = false

-- Called after each mission ends
local function onMissionComplete()
    if not autoTrackEnabled then return end
    local count = getMissionCount() + 1
    print("[Mission] Completed mission", count)
    if count >= 10 then
        teleportToLobby()
    else
        setMissionCount(count)
    end
end

-- UI Toggle Setup (Rayfield/Orion/etc.)
local Toggle = Tabs.Extras:AddToggle("AutoUpgrade", {
    Title = "Auto Upgrade (10 mISSIONS)",
    Description = "Only tps to lobby do not use",
    Default = false,
    Callback = function(state)
        autoTrackEnabled = state
        print("AutoTrack is now", state and "ON" or "OFF")
    end
})


local function AutoAttackRaid_GetRemainingAmmo()
    local spearText = LocalPlayer.PlayerGui.Interface.HUD.Main.Top.Spears.Spears.Text
    return tonumber(string.match(spearText, "%d+")) or 0
end


local function WaitForSlayThenAdd()
    local Slay = ReplicatedStorage.Objectives:WaitForChild("Slay")
    local requirement = Slay:GetAttribute("Requirement")
    print("[WaitForSlayThenAdd] Waiting for Slay objective to reach requirement:", requirement)
    
    while toggleState and Slay.Value ~= requirement do
        task.wait(0.1)
    end
    if not toggleState then
        return
    end
    
    local args = {
        "Functions",
        "Retry",
        "Add"
    }
    ReplicatedStorage
        :WaitForChild("Assets")
        :WaitForChild("Remotes")
        :WaitForChild("GET")
        :InvokeServer(unpack(args))
        
    print("[WaitForSlayThenAdd] Slay objective met; GET remote fired with:", unpack(args))
	onMissionComplete()
end


local function MissionFarm_Run()
    task.wait(25) -- Optional delay before starting the farm

    while toggleState do
        local titansFolder = Workspace:FindFirstChild("Titans")
        if titansFolder then
            local targetNapes = {}

            for _, titan in ipairs(titansFolder:GetChildren()) do
                if not titan:FindFirstChild("Dead") then
                    local hitboxes = titan:FindFirstChild("Hitboxes")
                    local hit = hitboxes and hitboxes:FindFirstChild("Hit")
                    local nape = hit and hit:FindFirstChild("Nape")
                    
                    if nape and nape:IsA("BasePart") then
                        table.insert(targetNapes, nape.Position)
                    end
                end
            end

            if #targetNapes > 0 then
                local ammo = AutoAttackRaid_GetRemainingAmmo()
                if ammo > 0 then
                    ReplicatedStorage.Assets.Remotes.GET:InvokeServer("Spears", "S_Fire", tostring(ammo))
                    print("[MissionFarm] Fired spear. Ammo left:", ammo)
                    task.wait(0.1)

                    for _, pos in ipairs(targetNapes) do
                        ReplicatedStorage.Assets.Remotes.POST:FireServer("Spears", "S_Explode", pos, 0.11289310455322266, 777.47021484375)
                    end

                    print("[MissionFarm] Exploded at", #targetNapes, "napes.")
                else
                    print("[MissionFarm] No ammo!")
                end
            else
                print("[MissionFarm] No living titans found.")
            end
        end

        task.wait(7) -- Wait before repeating
    end
end

local Toggle = Tabs.Main:AddToggle("SpearMissionFarmToggle", {
    Title = "Spear Mission Farm",
    Description = ".",
    Default = false,
    Callback = function(state)
        toggleState = state
        if state then
            print("[Toggle] Mission farm activated!")

            -- Delete Climbable buildings
           local function deleteObstacles()
		   task.wait(3)
                for _, name in ipairs({"Climbable", "Points", "Unclimbable"}) do
                    local part = workspace:FindFirstChild(name)
                    if part then
                        part:Destroy()
                    end
                end
            end
            deleteObstacles()

            -- Hover the player
            local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            local rootPart = character:WaitForChild("HumanoidRootPart")
            local targetPos = rootPart.Position + Vector3.new(0, 500, 0)

            local bodyPosition = Instance.new("BodyPosition")
            bodyPosition.Parent = rootPart
            bodyPosition.Position = targetPos
            bodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bodyPosition.D = 50
            bodyPosition.P = 50

            local bodyGyro = Instance.new("BodyGyro")
            bodyGyro.Parent = rootPart
            bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
            bodyGyro.P = 50

            print(string.format("[Toggle] Hovering player to (%.2f, %.2f, %.2f)", targetPos.X, targetPos.Y, targetPos.Z))

            -- Start farming
            task.spawn(MissionFarm_Run)
            task.spawn(WaitForSlayThenAdd)
        else
            print("[Toggle] Mission farm deactivated.")
        end
    end
})


local MissionWait = 30 -- seconds delay before starting the actual autofarm

local Toggleopfarm = Tabs.Main:AddToggle("OP Autofarm", {
    Title = "OP Autofarm",
    Description = "Turn on the OP Autofarm",
    Default = false,
    Callback = function(OPAUTOFARM)
        local runService = game:GetService("RunService")
        local Players = game:GetService("Players")
        local workspace = game:GetService("Workspace")
        local VIP = game:GetService("VirtualInputManager")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local player = Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local rootPart = character:WaitForChild("HumanoidRootPart")

        local autofarmActive = false
        local retryCompleted = false

        -- Cleanup function
        local function cleanup()
            if getgenv().stopAutofarm then
                getgenv().stopAutofarm()
            end
        end

        if OPAUTOFARM then
            -- Create Body Movers
            local bodyPosition = Instance.new("BodyPosition")
            bodyPosition.Parent = rootPart
            bodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bodyPosition.D = 500
            bodyPosition.P = 5000

            local bodyGyro = Instance.new("BodyGyro")
            bodyGyro.Parent = rootPart
            bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
            bodyGyro.P = 2500

            -- Hover Position
            local startPos = rootPart.Position + Vector3.new(0, 500, 0)
            bodyPosition.Position = startPos

            runService.RenderStepped:Connect(function()
                bodyPosition.Position = startPos
                bodyGyro.CFrame = rootPart.CFrame
            end)

            -- Delete obstacles
            local function deleteObstacles()
                for _, name in ipairs({"Borders", "Climbable", "Points"}) do
                    local part = workspace:FindFirstChild(name)
                    if part then
                        part:Destroy()
                    end
                end
            end
            deleteObstacles()

            autofarmActive = true
            retryCompleted = false

            -- Autofarm coroutine
            local function autofarm()
                task.wait(MissionWait)

                while autofarmActive and not retryCompleted do
                    task.wait(0.9)
                    for _, titan in ipairs(workspace.Titans:GetChildren()) do
                        local Hitboxes = titan:FindFirstChild("Hitboxes")
                        local Hit = Hitboxes and Hitboxes:FindFirstChild("Hit")
                        local Nape = Hit and Hit:FindFirstChild("Nape")

                        if Nape then
                            Nape.Size = Vector3.new(250, 250, 250)
                            local frontOffset = rootPart.CFrame.LookVector * 5
                            Nape.Position = rootPart.Position + frontOffset
                            Nape.Anchored = true
                        end
                    end

                    -- Fire Skill 1 (Spear)
                    VIP:SendKeyEvent(true, Enum.KeyCode.One, false, game)
                    task.wait(0.1)

                    local Thrust = character:FindFirstChild("Thrust")
                    if Thrust then
                        Thrust.Size = Vector3.new(1999, 1999, 1999)
                        Thrust.CanCollide = false
                    end

                    task.wait(3)

                    -- Fire Skill 2 (Detonator)
                    VIP:SendKeyEvent(true, Enum.KeyCode.Two, false, game)
                    task.wait(0.1)

                    local Steel = character:FindFirstChild("Steel")
                    if Steel then
                        Steel.Size = Vector3.new(1999, 1999, 1999)
                        Steel.CanCollide = false
                    end

                    -- Check Slay Objective
                    local Slay = ReplicatedStorage.Objectives:WaitForChild("Slay")
                    local requirement = Slay:GetAttribute("Requirement")
                    while Slay.Value ~= requirement do
                        task.wait(0.1)
                    end

                    -- Retry the mission
                    local args = {
                        [1] = "Functions",
                        [2] = "Retry",
                        [3] = "Add"
                    }
                    ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("GET"):InvokeServer(unpack(args))
                    onMissionComplete()
                    retryCompleted = true
					
                end
            end

            -- Smart Skill firing (optional if autofarm is controlling skill usage)
            local function fireSkillX(keyCode, hotbarName)
                while autofarmActive and not retryCompleted do
                    local success = pcall(function()
                        local hotbar = player.PlayerGui.Interface.HUD.Main.Top.Hotbar
                        local skill = hotbar:FindFirstChild(hotbarName)
                        local cooldown = skill and skill:FindFirstChild("Cooldown")
                        if cooldown and not cooldown.Visible then
                            VIP:SendKeyEvent(true, keyCode, false, game)
                        end
                    end)
                    if not success then break end
                    task.wait(0.5)
                end
            end

            -- Coroutine management
            local function startCoroutine(func)
                local co = coroutine.create(func)
                coroutine.resume(co)
                return co
            end

            startCoroutine(autofarm)
            -- Optionally also use these if you want skill spam during wait time:
            -- startCoroutine(function() fireSkillX(Enum.KeyCode.One, "Skill_1") end)
            -- startCoroutine(function() fireSkillX(Enum.KeyCode.Two, "Skill_2") end)

            -- Optional: Reset watchdog
            spawn(function()
                while autofarmActive do
                    task.wait(10)
                end
            end)

            -- Stop function for cleanup
            getgenv().stopAutofarm = function()
                autofarmActive = false
                retryCompleted = false
            end
        else
            cleanup()
        end
    end
})




function sendMessage(title, description, items)
    local itemString = table.concat(items, "\n")
    local data = {
        content = "",
        embeds = {{
            title = title,
            description = (description .. "\n" .. itemString),
            color = 4286945 
        }}
    }
    local actual = http:JSONEncode(data)

    local success, response = pcall(function()
        request({
            Url = Webhook,
            Method = "POST",
            Body = actual,
            Headers = {
                ["content-Type"] = "application/json"
            }
        })
    end)
end


local spearHasFired = false 
local bladeHasFired = false 

local player = game:GetService("Players").LocalPlayer
local character = workspace.Characters[player.Name]

if not character then
    warn("Character not found for player:", player.Name)
    return
end

local rig = character["Rig_" .. player.Name] 

if not rig then
    warn("Rig not found for player:", "Rig_" .. player.Name)
    return
end

local function checkBladesTransparent()
    local blades = {
        rig.LeftHand.Blade_1,
        rig.LeftHand.Blade_2,
        rig.LeftHand.Blade_3,
        rig.RightHand.Blade_1,
        rig.RightHand.Blade_2,
        rig.RightHand.Blade_3
    }

    for _, blade in pairs(blades) do
        if blade and blade.Transparency ~= 1 then
            return false
        end
    end
    return true
end

local Togglespearrefill = Tabs.Extras:AddToggle("Spear Refill", 
{
    Title = "Auto Spear Refill", 
    Description = "Auto refill your spears",
    Default = false,
    Callback = function(state)
        if state then
            local function checkAndRefillSpear()
                local whentofirespearrefill = game:GetService("Players").LocalPlayer.PlayerGui.Interface.HUD.Main.Top.Spears.Spears.Text
                if string.find(whentofirespearrefill, "0") and not spearHasFired then
                    local args = {
                        [1] = "Spears",
                        [2] = "Full_Reload",
                        [3] = "Right",
                        [4] = workspace:WaitForChild("Unclimbable"):WaitForChild("Reloads"):WaitForChild("GasTanks"):WaitForChild("Refill")
                    }
                    game:GetService("ReplicatedStorage"):WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("POST"):FireServer(unpack(args))

                    args = {
                        [1] = "Spears",
                        [2] = "Full_Reload",
                        [3] = "Left",
                        [4] = workspace:WaitForChild("Unclimbable"):WaitForChild("Reloads"):WaitForChild("GasTanks"):WaitForChild("Refill")
                    }
                    game:GetService("ReplicatedStorage"):WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("POST"):FireServer(unpack(args))
                    
                    spearHasFired = true
                end
            end

            local spearConnection
            spearConnection = game:GetService("Players").LocalPlayer.PlayerGui.Interface.HUD.Main.Top.Spears.Spears:GetPropertyChangedSignal("Text"):Connect(function()
                local whentofirespearrefill = game:GetService("Players").LocalPlayer.PlayerGui.Interface.HUD.Main.Top.Spears.Spears.Text
                   if string.find(whentofirespearrefill, "0") then

                    checkAndRefillSpear()
                else
                    spearHasFired = false 
                end
            end)

            checkAndRefillSpear()
        end 
    end 
})

local Togglebladerefill = Tabs.Extras:AddToggle("Blade Refill", 
{
    Title = "Auto Blade Refill", 
    Description = "Auto refill your blades",
    Default = false,
    Callback = function(state)
        if state then
            local function checkAndRefillBlade()
                local whentofirebladerefill = game:GetService("Players").LocalPlayer.PlayerGui.Interface.HUD.Main.Top.Blades.Sets.Text
                if whentofirebladerefill == "0 / 3" and checkBladesTransparent() and not bladeHasFired then
                    local args = {
                        [1] = "Blades",
                        [2] = "Full_Reload",
                        [3] = "Right",
                        [4] = workspace:WaitForChild("Unclimbable"):WaitForChild("Reloads"):WaitForChild("GasTanks"):WaitForChild("Refill")
                    }
                    game:GetService("ReplicatedStorage"):WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("POST"):FireServer(unpack(args))

                   local args = {
                        [1] = "Blades",
                        [2] = "Full_Reload",
                        [3] = "Left",
                        [4] = workspace:WaitForChild("Unclimbable"):WaitForChild("Reloads"):WaitForChild("GasTanks"):WaitForChild("Refill")
                    }
                    game:GetService("ReplicatedStorage"):WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("POST"):FireServer(unpack(args))
                    
                    bladeHasFired = true
                end
            end

            local bladeConnection
            bladeConnection = game:GetService("RunService").Stepped:Connect(function()
                if not bladeHasFired then
                    checkAndRefillBlade()
                end
            end)

            local textConnection
            textConnection = game:GetService("Players").LocalPlayer.PlayerGui.Interface.HUD.Main.Top.Blades.Sets:GetPropertyChangedSignal("Text"):Connect(function()
                local whentofirebladerefill = game:GetService("Players").LocalPlayer.PlayerGui.Interface.HUD.Main.Top.Blades.Sets.Text
                if whentofirebladerefill ~= "0 / 3" then
                    bladeHasFired = false 
                end
            end)

            checkAndRefillBlade()
        end 
    end 
})



local function sendPlainTextMessage(message)
    local data = {
        content = message
    }
    local actual = http:JSONEncode(data)

    local success, response = pcall(function()
        request({
            Url = Webhook,
            Method = "POST",
            Body = actual,
            Headers = {
                ["content-Type"] = "application/json"
            }
        })
    end)
end


Tabs.Misc:AddButton({
    Title = "Teleport to lobby",
    Description = "Click to teleport",
    Callback = function()
        local placeId = 14916516914 
        local player = game.Players.LocalPlayer

        if player then
            TeleportService:Teleport(placeId, player)
        end
    end
})

local stopCoroutine = false

local function applyEffectToChildren(hand, particleFolder)
    for _, child in ipairs(hand:GetChildren()) do
        for _, particle in ipairs(particleFolder:GetChildren()) do
            local particleTemplate = particle:Clone()
            particleTemplate.Parent = child
        end
    end
end

local function monitorTransparency(hand, selectedAuraFolder)
    while not stopCoroutine do
        for _, child in ipairs(hand:GetChildren()) do
            if child and child.Transparency == 1 then
                for _, emitter in ipairs(child:GetChildren()) do
                    if emitter:IsA("ParticleEmitter") then
                        emitter.Enabled = false
                    end
                end
            elseif child and child.Transparency < 1 then
                if selectedAuraFolder then
                    for _, particle in ipairs(selectedAuraFolder:GetChildren()) do
                        if not child:FindFirstChild(particle.Name) then
                            local particleTemplate = particle:Clone()
                            particleTemplate.Parent = child
                        else
                            local existingParticle = child:FindFirstChild(particle.Name)
                            if existingParticle:IsA("ParticleEmitter") then
                                existingParticle.Enabled = true
                            end
                        end
                    end
                end
            end
        end
        task.wait(0.1) 
    end
end

local function removeParticles(hand)
    for _, child in ipairs(hand:GetChildren()) do
        for _, emitter in ipairs(child:GetChildren()) do
            if emitter:IsA("ParticleEmitter") then
                emitter:Destroy()
            end
        end
    end
end

local auraFolder = game:GetService("ReplicatedStorage").Assets.Auras
local auraNames = {"Default"} 
for _, aura in ipairs(auraFolder:GetChildren()) do
    table.insert(auraNames, aura.Name)
end

local AuraDropdown = Tabs.Extras:AddDropdown("AuraDropdown", {
    Title = "Select Aura",
    Description = "Choose an aura to apply to the blades.",
    Values = auraNames,
    Multi = false,
    Default = "Default", 
})

AuraDropdown:SetValue("Default")

AuraDropdown:OnChanged(function(selectedAura)
    stopCoroutine = true
    task.wait(0.2)
    stopCoroutine = false

    local LocalPlayer = game.Players.LocalPlayer
    local characterName = LocalPlayer.Name
    removeParticles(workspace.Characters[characterName]["Rig_"..characterName].RightHand)
    removeParticles(workspace.Characters[characterName]["Rig_"..characterName].LeftHand)

    if selectedAura and selectedAura ~= "Default" then
        local selectedAuraFolder = auraFolder:FindFirstChild(selectedAura)
        if selectedAuraFolder then
            applyEffectToChildren(workspace.Characters[characterName]["Rig_"..characterName].RightHand, selectedAuraFolder)
            applyEffectToChildren(workspace.Characters[characterName]["Rig_"..characterName].LeftHand, selectedAuraFolder)
            coroutine.wrap(monitorTransparency)(workspace.Characters[characterName]["Rig_"..characterName].RightHand, selectedAuraFolder)
            coroutine.wrap(monitorTransparency)(workspace.Characters[characterName]["Rig_"..characterName].LeftHand, selectedAuraFolder)
        end
    end
end)


local ToggleTracker = Tabs.Extras:AddToggle("Rewards Tracker", {
    Title = "Rewards Tracker",
    Description = "Turn on the Rewards Tracker",
    Default = false,
    Callback = function(Value)
        local hasSentItems = false

        while Value do
            if Webhook == "" then
                Fluent:Notify({
                    Title = "Enter a webhook to use Rewards Tracker",
                    Content = "Please Enter a webhook in the script",
                    SubContent = "Thank you", 
                    Duration = 5 
                })
                return 
            end

            local startgui = LocalPlayer:WaitForChild("PlayerGui")
            local interface = startgui:WaitForChild("Interface")
            local stepone = interface:WaitForChild("Rewards")
            local steptwo = stepone:WaitForChild("Main")
            local stepthree = steptwo:WaitForChild("Info")
            local stepfour = stepthree:WaitForChild("Main")
            local stepfive = stepfour:WaitForChild("Items")

            local statsFolder = stepfour:WaitForChild("Stats")

            local slay = ReplicatedStorage:WaitForChild("Objectives"):WaitForChild("Slay")

            local value = slay.Value
            local requirement = slay:GetAttribute("Requirement")

            if value and requirement and value >= requirement and not hasSentItems then
                task.wait(1)
                local itemsList = {}
                if stepfive then
                    for _, item in pairs(stepfive:GetChildren()) do
                        if item.Name ~= "Grid" then
                            local quantity = item:FindFirstChild("Main") and item.Main:FindFirstChild("Inner") and item.Main.Inner:FindFirstChild("Quantity") and item.Main.Inner.Quantity.Text or "unknown"
                            local itemName = item.Name:gsub("_", " ") 
                            table.insert(itemsList, itemName .. ": " .. quantity)
                        end
                    end
                end

                local statsList = {}
                for _, stat in pairs(statsFolder:GetChildren()) do
                    if stat.Name ~= "List" then 
                        local statName = stat.Name:gsub("_", " ")
                        local statAmount = stat:FindFirstChild("Amount") and stat.Amount.Text or "unknown"
                        table.insert(statsList, statName .. ": " .. statAmount)
                    end
                end

                local specialRewards = {}
                for _, item in pairs(itemsList) do
                    if string.find(item, "Serum") or string.find(item, "Secret Perk") then
                        table.insert(specialRewards, item)
                    end
                end

                if #specialRewards == 0 then
                    table.insert(specialRewards, "No Special Rewards")
                end

                local combinedList = {}
                table.insert(combinedList, "**Items:**")
                for _, item in pairs(itemsList) do
                    table.insert(combinedList, item)
                end

                table.insert(combinedList, "\n**Statistics:**")
                for _, stat in pairs(statsList) do
                    table.insert(combinedList, stat)
                end

                table.insert(combinedList, "\n**Special Rewards:**")
                for _, specialReward in pairs(specialRewards) do
                    table.insert(combinedList, specialReward)
                end

                local playerName = LocalPlayer.Name
                table.insert(combinedList, "\n**Player:**\n" .. playerName)

                sendMessage("Rewards Tracker", "", combinedList)

                hasSentItems = true

if #specialRewards > 0 and specialRewards[1] ~= "No Special Rewards" then
    local pingMessage = "<@" .. discordID .. ">, you have received a special reward!"

    sendPlainTextMessage(pingMessage)
end


            end
            task.wait(0.5)
        end
    end
})

local function AimbotNape()
    while getgenv().Aimbot_Nape do
        for _, titans in pairs(game:GetService("Workspace").Titans:GetChildren()) do
            local stepone = titans:FindFirstChild("Hitboxes")
            if stepone then
                local steptwo = stepone:FindFirstChild("Hit")
                if steptwo then
                    local final = steptwo:FindFirstChild("Nape")
                    if final then
                        final.Size = Vector3.new(25, 25, 25)
                        final.Transparency = 0.85
                        final.CanCollide = false
                    end
                end
            end
        end
        task.wait(0.1)
    end
end

local Toggleforflyfarm = Tabs.Main:AddToggle("FlyFarm", 
{
    Title = "FlyFarm", 
    Description = "Turn on the fly farm (WARNING) in beta",
    Default = false,
    Callback = function(state)
	if state then

speed = 20

local Players = game:GetService("Players")
local workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")

local remotesFired = false
local blacklistedTitans = {}  

local function enableNoclipForParts(parts)
    for _, part in pairs(parts) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
end

local function enableNoclipForCharacters()
    for _, character in pairs(workspace:WaitForChild("Characters"):GetChildren()) do
        enableNoclipForParts(character:GetDescendants()) 
    end
end

local function disableNoclipForParts(parts)
    for _, part in pairs(parts) do
        if part:IsA("BasePart") then
            part.CanCollide = true
        end
    end
end

local function disableNoclipForCharacters()
    for _, character in pairs(workspace:WaitForChild("Characters"):GetChildren()) do
        disableNoclipForParts(character:GetDescendants())  
    end
end

local function getClosestTitan(player, excludeTitan)
    local closestTitan = nil
    local shortestDistance = math.huge  

    for _, titan in pairs(workspace:WaitForChild("Titans"):GetChildren()) do
        if titan ~= excludeTitan and titan.Parent and not blacklistedTitans[titan] then  
            local titanPart = titan:FindFirstChild("HumanoidRootPart")
            if titanPart then
                local distance = (player.Character.HumanoidRootPart.Position - titanPart.Position).magnitude
                if distance < shortestDistance then
                    closestTitan = titan
                    shortestDistance = distance
                end
            end
        end
    end
    return closestTitan
end

local function moveToTitanAndHover(titan)
    local rootPart = character:WaitForChild("HumanoidRootPart")

    local bodyPosition = Instance.new("BodyPosition")
    bodyPosition.Parent = rootPart
    bodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyPosition.D = 300  
    bodyPosition.P = 2500  

    local bodyGyro = Instance.new("BodyGyro")
    bodyGyro.Parent = rootPart
    bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    bodyGyro.P = 1000  

    enableNoclipForCharacters()

    game:GetService("RunService").Heartbeat:Connect(function()
        local closestTitan = getClosestTitan(player, nil)
        if closestTitan then
            local targetPosition = closestTitan:WaitForChild("HumanoidRootPart").Position + Vector3.new(0, 50, 0)  
            local hoverHeight = 50
            local distanceToTarget = (rootPart.Position - targetPosition).magnitude

            if distanceToTarget > 1 then
                local direction = (targetPosition - rootPart.Position).unit
                local moveAmount = direction * speed
                bodyPosition.Position = rootPart.Position + moveAmount  
            else
                
                rootPart.AssemblyLinearVelocity = Vector3.zero
                bodyPosition.Position = targetPosition  

                if (rootPart.Position.Y - closestTitan.HumanoidRootPart.Position.Y) >= hoverHeight and not remotesFired then
                    local args1 = {"Attacks", "Slash", true}
                    ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("POST"):FireServer(unpack(args1))

                    local args2 = {"Hitboxes", "Register", closestTitan:WaitForChild("Hitboxes"):WaitForChild("Hit"):WaitForChild("Nape"), 129.8856658935547, 0.15462923049926758}
                    ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("POST"):FireServer(unpack(args2))

                    local args3 = {"Attacks", "Slash", false}
                    ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("POST"):FireServer(unpack(args3))

                    remotesFired = true

                    while not closestTitan:GetAttribute("Dead") do
                        task.wait(0.1)
                    end
                    
                    if closestTitan:GetAttribute("Dead") then
                        blacklistedTitans[closestTitan] = true  
                    end

                    bodyPosition:Destroy()  
                    bodyGyro:Destroy() 
                    disableNoclipForCharacters()  

                    local newTitan = getClosestTitan(player, closestTitan)
                    if newTitan then
                        moveToTitanAndHover(newTitan)
                    end

                    return  
                end
            end
        else
            bodyPosition:Destroy()  
            bodyGyro:Destroy()  
            disableNoclipForCharacters()  
            return  
        end
    end)
end

local function interactWithTitans()
    while true do
        local closestTitan = getClosestTitan(player, nil)
        if closestTitan then
            remotesFired = false
            moveToTitanAndHover(closestTitan)
        else
            break
        end
        task.wait(1)  
    end
end

interactWithTitans()

local VIP = game:GetService("VirtualInputManager")
local Slay = ReplicatedStorage.Objectives:WaitForChild("Slay")
local requirement = Slay:GetAttribute("Requirement")
while Slay.Value ~= requirement do
    task.wait(0.1)
end

task.wait(3)
VIP:SendKeyEvent(true, Enum.KeyCode.BackSlash, false, game)
task.wait(0.1)
VIP:SendKeyEvent(true, Enum.KeyCode.Right, false, game)
task.wait(0.1)
VIP:SendKeyEvent(true, Enum.KeyCode.Right, false, game)
task.wait(0.1)
VIP:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
task.wait(0.1)
VIP:SendKeyEvent(false, Enum.KeyCode.Return, false, game)


        end
    end 
})


local function napeExtender()
    while getgenv().napeExtender do
        for _, titans in pairs(game:GetService("Workspace").Titans:GetChildren()) do
            local stepone = titans:FindFirstChild("Hitboxes")
            if stepone then
                local steptwo = stepone:FindFirstChild("Hit")
                if steptwo then
                    local final = steptwo:FindFirstChild("Nape")
                    if final then
                        final.Size = Vector3.new(250, 250, 250)
                        final.Transparency = 0.85
                        final.CanCollide = false
                    end
                end
            end
        end
        task.wait(0.1)
    end
end

local TogglePerformance = Tabs.Misc:AddToggle("Performance Mode", 
{
    Title = "Performance Mode", 
    Description = "Toggle Performance Mode",
    Default = false,
    Callback = function(state)
        if state then
		local delneeded = workspace.Climbable:GetChildren()
            game:GetService("Lighting").Atmosphere.Density = 0
            local delneeded = workspace.Climbable:GetChildren()
            for _, v in pairs(delneeded) do
                v:Destroy()
            end

            local decalsyeeted = true
            local g = game
            local w = g.Workspace
            local l = g.Lighting
            local t = w.Terrain
            
            t.WaterWaveSize = 0
            t.WaterWaveSpeed = 0
            t.WaterReflectance = 0
            t.WaterTransparency = 0
            l.GlobalShadows = false
            l.FogEnd = math.huge
            l.Brightness = 0
            settings().Rendering.QualityLevel = Enum.QualityLevel.Level06
            
            local function disableEffects(effectClass)
                for _, effect in pairs(l:GetChildren()) do
                    if effect:IsA(effectClass) then
                        effect.Enabled = false
                    end
                end
            end
            
            disableEffects("BlurEffect")
            disableEffects("SunRaysEffect")
            disableEffects("ColorCorrectionEffect")
            disableEffects("BloomEffect")
            disableEffects("DepthOfFieldEffect")

            local descendants = g:GetDescendants()
            for _, v in pairs(descendants) do
                if v:IsA("Part") or v:IsA("Union") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
                    v.Material = Enum.Material.Plastic
                    v.Reflectance = 0
                elseif v:IsA("Decal") or (v:IsA("Texture") and decalsyeeted) then
                    v.Transparency = 1
                elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
                    v.Lifetime = NumberRange.new(0)
                elseif v:IsA("Explosion") then
                    v.BlastPressure = 1
                    v.BlastRadius = 1
                elseif v:IsA("Fire") or v:IsA("SpotLight") or v:IsA("Smoke") then
                    v.Enabled = false
                elseif v:IsA("MeshPart") then
                    v.Material = Enum.Material.Plastic
                    v.Reflectance = 0
                    v.TextureID = 10385902758728956
                end
            end
        end
    end
})

local Toggleretrydelay = Tabs.Misc:AddToggle("Retry On Delay", 
{
    Title = "Retry on Delay", 
    Description = "Auto retry when the timer is reached (uses remotes)",
    Default = false,
    Callback = function(retrydelay)
        if retrydelay then
            task.wait(RetryDelay)

            local args = {
                [1] = "Functions",
                [2] = "Retry",
                [3] = "Add"
            }
onMissionComplete()
            game:GetService("ReplicatedStorage"):WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("GET"):InvokeServer(unpack(args))
        end
    end
})
local player = game:GetService("Players").LocalPlayer
local function DestroyInjuries()
    local character = game:GetService("Workspace").Characters:FindFirstChild(player.Name);
    if character then
        local injuriesFolder = character:FindFirstChild("Injuries");
        if injuriesFolder then
            for _, injury in pairs(injuriesFolder:GetChildren()) do
                injury:Destroy();
            end
    end
end
end
local ToggleAntiInjury = Tabs.Main:AddToggle("DestroyInjuries", 
{
    Title = "Anti-Injury", 
    Description = "Removes Injuries entirely",
    Default = false,
    Callback = function(togglestate)
        if togglestate then
            while togglestate do
                task.wait(0.1);
                DestroyInjuries();
            end
        end
    end
})
getgenv().napeExtender = false
getgenv().Aimbot_Nape = false
local ToggleAimbot = Tabs.Main:AddToggle("Nape Aimbot", {
    Title = "Nape Aimbot",
    Description = "More discrete version of nape extender",
    Default = false,
    Callback = function(NapeAimbot)
        if NapeAimbot then
            getgenv().Aimbot_Nape = NapeAimbot
            spawn(AimbotNape)
        else
            getgenv().Aimbot_Nape = false
        end
    end
})
local ToggleExtender = Tabs.Main:AddToggle("Nape Extender", {
    Title = "Nape Extender",
    Description = "Extends the nape",
    Default = false,
    Callback = function(NapeXtender)
        if NapeXtender then
            getgenv().napeExtender = NapeXtender
            spawn(napeExtender)
        else
            getgenv().napeExtender = false
        end
    end
})

local Togglebladereload = Tabs.Extras:AddToggle("Auto Reload Blade", 
{
    Title = "Auto Reload Blade", 
    Description = "NOT AUTO REFILL",
    Default = false,
    Callback = function(togglestate)
        autor = togglestate
        getgenv().autor = togglestate

        if togglestate then
            task.spawn(function()
                while task.wait() do
                    if not getgenv().autor then return end
                    local player = game.Players.LocalPlayer
                    local character = player.Character or player.CharacterAdded:Wait()
                    local rig = character:FindFirstChild("Rig_" .. player.Name)
                    
                    if rig then
                        for i, v in pairs(rig:GetChildren()) do
                            if v.Name == "RightHand" or v.Name == "LeftHand" then
                                for i, v2 in pairs(v:GetChildren()) do
                                    if v2.Name == "Blade_1" then
                                        if v2:GetAttribute("Broken") ~= nil and v2:GetAttribute("Broken") == true then
local VIP = game:GetService("VirtualInputManager")
                                    VIP:SendKeyEvent(true, Enum.KeyCode.R, false, game)
task.wait(0.1)
                                    VIP:SendKeyEvent(false, Enum.KeyCode.R, false, game)

                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end)
        end
    end
})

SaveManager:LoadAutoloadConfig()
-- hi bestier


local VIM = game:GetService("VirtualInputManager");
getgenv().autoescape = true;
while task.wait(0.3) do
	if not getgenv().autoescape then
		return;
	end
	for _, v in pairs(game:GetService("Players").LocalPlayer.PlayerGui.Interface.Buttons:GetChildren()) do
		if v then
			VIM:SendKeyEvent(true, string.sub(tostring(v), 1, 1), false, game);
			if v.AncestryChanged then
				v.AncestryChanged:Connect(function()
					if not v:IsDescendantOf(game:GetService("Players").LocalPlayer.PlayerGui.Interface.Buttons) then
						VIM:SendKeyEvent(false, string.sub(tostring(v), 1, 1), false, game);
					end
				end);
			end
		end
	end
end
end


-- hi I assume your 25ms if your seeing this, Welcome to my shit code	


-- Example usage: Call onMissionComplete() after each mission is finished
-- This could be hooked into your mission completion event


